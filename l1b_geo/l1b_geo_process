#! /usr/bin/env python
#
# This runs the L1B Geo process.
import geocal
import ecostress
import os
import re
import shutil
import h5py
import traceback
from multiprocessing import Pool
import numpy as np

# Get version information, in the top directory
import sys
sys.path.append(os.path.dirname(os.path.abspath(sys.path[0])))
from ecostress_version import *

version = "1.0"
usage='''Usage:
  l1b_geo_process [options] <run_config>
  l1b_geo_process [options] <l1a_raw_att> <osp_dir> <prod_dir> <l1b_rad>...
  l1b_geo_process -h | --help
  l1b_geo_process -v | --version

This runs the L1B Geo process.

Options:
  -h --help         
       Print this message

  --ecostress-band=d
       Ecostress band to use. Band 1 is 8.28 micron, Band 2 is 8.63
       and so on. By convention Band 0 is the SWIR band. -1 means 
       use the value found in the configuration file
       [default: -1]

  --force-night
       Testing option to force the data to be treated as night, overriding
       what the l1b_rad data says.

  --landsat-band=d
       Landsat band to match to. For band 6, we have both low and high gain.
       Enter this as 61 and 62. -1 means use the value found in the
       configuration file [default: -1]

  --number-cpu=d
       Number of CPUs to use when processing. Ignored if we are using a 
       run_config file, this is instead passed through the config file.
       [default: 10]

  --number-line=d
       Number of lines to process. Normally you process the whole scene, but
       can be useful for testing to process only a subset. [default: -1]

  --orbit-offset=d
       For testing, fake errors in the orbit. This is an alternative from
       running the full end-to-end test generation, where we take the orbit
       from l1a_raw but then add errors. The errors should be the yaw,pitch,
       roll errors to add in degrees.

  -v --version      
       Print program version
'''

args = geocal.docopt_simple(usage, version=version)

# Can use this to wait a short time so we can attach strace to this
# process, useful to find all the files that we are accessing.
if(False):
    print("Waiting a short time")
    import time
    time.sleep(20)

if(args.run_config):
    config = ecostress.RunConfig(args.run_config)
    l1_osp_dir = os.path.abspath(config["StaticAncillaryFileGroup", "L1_OSP_DIR"])
else:    
    config = None
    l1_osp_dir = os.path.abspath(args.osp_dir)

# Read in additional configuration parameters    
sys.path.append(l1_osp_dir)
import l1b_geo_config
    
if(args.run_config):
    ncpu = int(config["Process", "NumberCpu"])
    orb = ecostress.create_orbit_raw(config,
                   pos_off=l1b_geo_config.x_offset_iss,
                   extrapolation_pad=l1b_geo_config.extrapolation_pad,
                   large_gap=l1b_geo_config.large_gap)
    dem = ecostress.create_dem(config)
    lwm = ecostress.create_lwm(config)
    ortho_base_dir = ecostress.ortho_base_directory(config)
    radlist = config.as_list("InputFileGroup", "L1B_RAD")
    radlist = [os.path.abspath(f) for f in radlist]
    dirname = config["ProductPathGroup", "ProductPath"]
    file_version = config["ProductPathGroup", "ProductCounter"]
    build_id = config["PrimaryExecutable", "BuildID"]
    orbfname = os.path.abspath(config["TimeBasedFileGroup", "L1A_RAW_ATT"])
else:
    ncpu = args.number_cpu
    dirname = os.path.abspath(args.prod_dir)
    file_version = "01"
    orbfname = os.path.abspath(args.l1a_raw_att)
    orb = ecostress.EcostressOrbit(orbfname, l1b_geo_config.x_offset_iss,
                                   l1b_geo_config.extrapolation_pad,
                                   l1b_geo_config.large_gap)
    dem = geocal.SrtmDem(os.environ["ELEV_ROOT"],False,
                  geocal.DatumGeoid96(os.environ["AFIDS_VDEV_DATA"] +
                               "/EGM96_20_x100.HLF"))
    if(os.path.exists("/raid27/tllogan/all_lwm_links")):
        lwm = geocal.SrtmLwmData("/raid27/tllogan/all_lwm_links", False)
    elif(os.path.exists("/project/ancillary/SRTM/srtm_v3_lwm")):
        lwm = geocal.SrtmLwmData("/project/ancillary/SRTM/srtm_v3_lwm", False)
    else:
        raise RuntimeError("Can't find land/water mask data")
    if(os.path.exists("/raid22/band5_VICAR")):
        ortho_base_dir = "/raid22"
    elif(os.path.exists("/data/smyth/Landsat/band5_VICAR")):
        ortho_base_dir = "/data/smyth/Landsat"
    elif(os.path.exists("/project/ancillary/LANDSAT")):
        ortho_base_dir = "/project/ancillary/LANDSAT"
    else:
        raise RuntimeError("Can't find Landsat global orthobase data")
    radlist = [os.path.abspath(f) for f in args.l1b_rad]


# Short function to print and log at the same time
def print_and_log(s):
    print(s)
    log = open(log_fname, "a")
    print("INFO:L1B_GEO_PGE:%s" % s, file=log)
    log.flush()
    log=None

def report_and_log_exception():
    print("EXCEPTION:*******************************************")
    print("Exception occurred while running SBA/Tiepoint")
    traceback.print_exc()
    print("SBA/Tiepoint failed to correct orbit data. Continue processing without correction.")
    print("EXCEPTION:*******************************************")
    qa_file.encountered_exception = True
    log = open(log_fname, "a")
    print("EXCEPTION:*******************************************",
          file = self.log)
    print("INFO:L1B_GEO:Exception occurred while running SBA/Tiepoint", file = log)
    traceback.print_exc(file=log)
    print("INFO:L1B_GEO:SBA/Tiepoint failed to correct orbit data. Continue processing without correction.", file=log)
    print("EXCEPTION:*******************************************",
          file = self.log)
    log.flush()
    log = None
    
# Determine bands to match

if(args.landsat_band == -1):
    lband_day = l1b_geo_config.landsat_day_band
    lband_night = l1b_geo_config.landsat_night_band
else:
    lband_day = args.landsat_band
    lband_night = args.landsat_band

ortho_base_day = geocal.Landsat7Global(ortho_base_dir,
                            ecostress.band_to_landsat_band(lband_day))
ortho_base_night = geocal.Landsat7Global(ortho_base_dir,
                            ecostress.band_to_landsat_band(lband_night))

if(args.ecostress_band == -1):
    eband_day = l1b_geo_config.ecostress_day_band
    eband_night = l1b_geo_config.ecostress_night_band
else:
    eband_day = args.ecostress_band
    eband_night = eband_day
    
if(args.orbit_offset):
    print_and_log("Add in orbit errors %s" % args.orbit_offset)
    # Want this in arcseconds, because this is what OrbitOffsetCorrection
    # takes
    yaw,pitch,roll = [float(i) * 60 * 60 for i in args.orbit_offset.split(",")]
    orb = geocal.OrbitOffsetCorrection(orb)
    orb.insert_attitude_time_point(orb.min_time)
    orb.insert_attitude_time_point(orb.max_time)
    orb.parameter = [yaw,pitch,roll] * 2
    orb.fit_position_x = False
    orb.fit_position_y = False
    orb.fit_position_z = False
    orb.fit_yaw = False
    orb.fit_pitch = False
    orb.fit_roll = False
orb = geocal.OrbitOffsetCorrection(orb)
cam = geocal.read_shelve(l1_osp_dir + "/camera.xml")
# Don't fit any of the camera parameters, hold them all fixed
cam.mask_all_parameter()
# Update focal length. We may put this into the camera.xml file, but for now
# we track this separately.
cam.focal_length = l1b_geo_config.camera_focal_length

geocal.makedirs_p(dirname)
os.chdir(dirname)

# Reorder radlist by acquisition_time, it isn't necessarily given to us
# in order.
radlist = sorted(radlist, key=lambda f : ecostress.orbit_from_metadata(f)[2])

inlist = [orbfname, *radlist]
inlist.append(l1_osp_dir + "/l1b_geo_config.py", )
log_fname = None
qa_file = None
try:
    if(ncpu > 1):
        pool = Pool(ncpu)
    else:
        pool = None
    # Determine output file names
    ofile = []
    ofile_map = []
    ofile_kmz = []
    is_day = []
    ortho_base = []
    scenelist = []
    for i in range(len(radlist)):
        orbit, scene, acquisition_time = ecostress.orbit_from_metadata(radlist[i])
        ofile.append(ecostress.ecostress_file_name("L1B_GEO", orbit, scene,
            acquisition_time, build = build_id,
            version = file_version))
        ofile_map.append(ecostress.ecostress_file_name("L1B_MAP_RAD", orbit,
            scene, acquisition_time, build = build_id,
            version = file_version))
        ofile_kmz.append(ecostress.ecostress_file_name("L1B_KMZ_MAP", orbit,
            scene,
            acquisition_time, build = build_id,
            extension=".kmz",                                           
            version = file_version, intermediate=True))
        scenelist.append(scene)
        if(i == 0):
            ofile2 = ecostress.ecostress_file_name("L1B_ATT", orbit, None,
                                                   acquisition_time,
                                                   build = build_id, 
                                                   version = file_version)
            qa_fname = ecostress.ecostress_file_name("L1B_GEO_QA", orbit, None,
                                                     acquisition_time,
                                                     build = build_id, 
                                                     version = file_version,
                                                     intermediate=True)

    log_fname = os.path.splitext(ofile[0])[0] + ".log"
    qa_file = ecostress.L1bGeoQaFile(qa_fname, log_fname)
    qa_file.input_list(inlist)
    
    # Create igc/tiepoint for all the data
    igccol_initial = ecostress.EcostressIgcCollection()
    with open("extra_python_init.py", "w") as fh:
        print("from ecostress import *\n", file=fh)
    for i in range(len(radlist)):
        tt = ecostress.create_time_table(radlist[i], l1b_geo_config.mirror_rpm,
                                         l1b_geo_config.frame_time)
        sm = ecostress.create_scan_mirror(radlist[i],
                                          l1b_geo_config.max_encoder_value,
                                          l1b_geo_config.first_encoder_value_0,
                                          l1b_geo_config.second_encoder_value_0,
                                          l1b_geo_config.instrument_to_sc_euler,
                                          l1b_geo_config.first_angle_per_encoder_value,
                                          l1b_geo_config.second_angle_per_encoder_value)
        line_order_reversed = False
        if(h5py.File(radlist[i],"r")["/L1B_RADMetadata/RadScanLineOrder"][()] == "Reverse line order"):
            line_order_reversed = True
        if(i == 0):
            cam.line_order_reversed = line_order_reversed
        elif(cam.line_order_reversed != line_order_reversed):
            raise RuntimeError("Currently require that all L1B_RAD given to l1b_geo_process have the same line ordering (/L1B_RADMetadata/RadScanLineOrder")
        if(not args.force_night and
           h5py.File(radlist[i],"r")["StandardMetadata/DayNightFlag"][()] == "Day"):
            is_day.append(True)
            eband = eband_day
            lband = lband_day
            ortho_base.append(ortho_base_day)
        else:
            is_day.append(False)
            eband = eband_night
            lband = lband_night
            ortho_base.append(ortho_base_night)
        # Work with the SWIR channel data
        if(eband ==0):
            ras = geocal.GdalRasterImage("HDF5:\"%s\"://SWIR/swir_dn" %
                                         radlist[i])
        else:
            ras = geocal.GdalRasterImage("HDF5:\"%s\"://Radiance/radiance_%d" %
                                         (radlist[i], eband))
            ras = geocal.ScaleImage(ras, 100.0)
        print_and_log("Scene %d is %s, matching ecostress band %d to Landsat band %d" % (scenelist[i], "Day" if is_day[i] else "Night", eband, lband))
        igccol_initial.add_igc(ecostress.EcostressImageGroundConnection(orb, tt, cam,
                          sm, dem, ras, "Scene %d" % scenelist[i]))

    # Project data to surface
    t = ecostress.L1bTpCollect(igccol_initial, ortho_base, qa_file,
                    fftsize=l1b_geo_config.fftsize,
                    magnify=l1b_geo_config.magnify,
                    magmin=l1b_geo_config.magmin,
                    toler=l1b_geo_config.toler,
                    redo=l1b_geo_config.redo,
                    ffthalf=l1b_geo_config.ffthalf,
                    seed=l1b_geo_config.seed,
                    num_x=l1b_geo_config.num_x,
                    num_y=l1b_geo_config.num_y,
                    log_fname=log_fname,
                    proj_number_subpixel=l1b_geo_config.proj_number_subpixel,
                    min_tp_per_scene=l1b_geo_config.min_tp_per_scene,
                    min_number_good_scan=l1b_geo_config.min_number_good_scan)
    correction_done = False
    igccol_corrected = igccol_initial
    tpcol = None
    if(not l1b_geo_config.skip_sba):
        tpcol, time_range_tp = t.tpcol(pool=pool)
        geocal.write_shelve("tpcol.xml", tpcol)
        # Add breakpoints for the scenes that we got good tiepoints from.
        # We may well tweak this, but right now we set breakpoints at the
        # beginning, middle and end of the scene, unless the beginning
        # is within one scene of another breakpoint.
        tlast = None
        for tmin, tmax in time_range_tp:
            if(tlast is None):
                orb.insert_position_time_point(tmin)
            if(tlast is None or tmin - tlast > 52.0):
                orb.insert_attitude_time_point(tmin)
            orb.insert_attitude_time_point(tmin + (tmax - tmin) / 2)
            orb.insert_attitude_time_point(tmax)
            tlast = tmax
        if(tlast is not None):
            orb.insert_position_time_point(tlast)
        geocal.write_shelve("igccol_initial.xml", igccol_initial)

        if(len(tpcol) == 0):
            print_and_log("No tie-points, so skipping SBA correction")
            tpcol = None
        else:
            try:
                log = open(log_fname, "a")
                ecostress.process_run(["sba", "--verbose",
                                       "--hold-gcp-fixed",
                                       "--gcp-sigma=50",  "igccol_initial.xml",
                                       "tpcol.xml", "igccol_sba.xml",
                                       "tpcol_sba.xml"],
                                      out_fh=log)
                log.flush()
                igccol_corrected = geocal.read_shelve("igccol_sba.xml")
                correction_done = True
            except Exception as e:
                if(not l1b_geo_config.continue_on_sba_fail):
                    raise
                report_and_log_exception()


    # Collect information on the time of the correction before and after
    # a scene
    tcorr_before= []
    tcorr_after= []
    geo_qa = []
    for i in range(len(radlist)):
        tt = igccol_corrected.image_ground_connection(i).time_table
        t = tt.min_time + (tt.max_time - tt.min_time)
        t1 = -9999
        t2 = -9999
        if(correction_done):
            tb, ta = igccol_corrected.nearest_attitude_time_point(t)
            if(tb < geocal.Time.max_valid_time - 1):
                t1 = t - tb
            if(ta < geocal.Time.max_valid_time - 1):
                t2 = t - ta
        tcorr_before.append(t1)
        tcorr_after.append(t2)
        geo_qa.append("No match")

    # Write out QA data
    if(tpcol):
        qa_file.add_final_accuracy(igccol_corrected, tpcol, tcorr_before,
                                   tcorr_after, geo_qa)
    qa_file.add_orbit(igccol_corrected.image_ground_connection(0).orbit)
    qa_file.write_xml("igccol_initial.xml", "tpcol.xml",
                      "igccol_sba.xml", "tpcol_sba.xml")

    # Generate output data
    avg_md = np.full((len(radlist), 2), -9999.0)
    for i in range(len(radlist)):
        # Generate output
        print_and_log("Doing scene number %d" % scenelist[i])
        fin = h5py.File(radlist[i],"r")
        if('BandSpecification' in fin["L1B_RADMetadata"]):
            nband = np.count_nonzero(fin["L1B_RADMetadata/BandSpecification"][:] > 0)
        else:
            nband = 6
        if(igccol_corrected.image_ground_connection(i).number_good_scan <
           l1b_geo_config.min_number_good_scan):
            print_and_log("Scene number %d has only %d good scans. We require a minimum of %d. Skipping output for this scene" %
           (scenelist[i],
            igccol_corrected.image_ground_connection(i).number_good_scan,
            l1b_geo_config.min_number_good_scan))
        elif(igccol_corrected.image_ground_connection(i).crosses_dateline):
            print_and_log("Scene number %d crosses date line. We don't handle this. Skipping output for this scene" % scenelist[i])
        else:
            l1bgeo = ecostress.L1bGeoGenerate(
                igccol_corrected.image_ground_connection(i),
                lwm, ofile[i],inlist,is_day[i],
                field_of_view_obscured = h5py.File(radlist[i],"r")["/StandardMetadata/FieldOfViewObstruction"][()],
                number_line = args.number_line,
                run_config = config, log_fname = log_fname,
                build_id = build_id,
                pge_version = pge_version["l1b_geo"],
                correction_done = correction_done,
                tcorr_before = tcorr_before[i],
                tcorr_after = tcorr_after[i],
                geolocation_accuracy_qa = geo_qa[i])
            l1bgeo.run(pool)
            avg_md[i,0 ] = l1bgeo.avg_sz
            avg_md[i,1 ] = l1bgeo.oa_lf
            if(l1b_geo_config.generate_map_product):
                print_and_log("Generating Map Product scene number %d" %
                              scenelist[i])
                l1bgeo_map = ecostress.L1bGeoGenerateMap(l1bgeo, radlist[i],
                   ofile_map[i],
                   north_up = l1b_geo_config.north_up,
                   resolution = l1b_geo_config.map_resolution,
                   number_subpixel = l1b_geo_config.map_number_subpixel)
                l1bgeo_map.run()
            if(l1b_geo_config.generate_kmz_file):
                print_and_log("Generating KMZ file scene number %d" %
                              scenelist[i])
                band_list = l1b_geo_config.kmz_band_list_5band if(nband == 6) else l1b_geo_config.kmz_band_list_3band
                l1bgeo_kmz = ecostress.L1bGeoGenerateKmz(l1bgeo, radlist[i],
                   ofile_kmz[i],
                   band_list=band_list,
                   use_jpeg=l1b_geo_config.kmz_use_jpeg,
                   resolution = l1b_geo_config.kmz_resolution,
                   thumbnail_size = l1b_geo_config.kmz_thumbnail_size,
                   number_subpixel = l1b_geo_config.kmz_number_subpixel)
                l1bgeo_kmz.run()
        
    qa_file.add_average_metadata(avg_md)
            
    
    # Write out updated orbit data
    fin = h5py.File(orbfname, "r")
    tatt = [geocal.Time.time_j2000(t) for t in fin["Attitude/time_j2000"][:]]
    teph = [geocal.Time.time_j2000(t) for t in fin["Ephemeris/time_j2000"][:]]
    l1batt = ecostress.L1bAttGenerate(orbfname,
            igccol_corrected.image_ground_connection(0).orbit,
            ofile2, tatt, teph, inlist, qa_file, run_config = config,
            build_id = build_id,
            pge_version = pge_version["l1b_geo"],
            correction_done = correction_done)
    l1batt.run()
    log = open(log_fname, "a")
    print("L1B_GEO_PGE:INFO-0-[Job Successful]", file=log)
    log.flush()
    qa_file.close()
    if(pool):
        pool.close()
except Exception as e:
    log = open(log_fname, "a")
    print("L1B_GEO_PGE: Exception thrown:",  file=log)
    traceback.print_exc(file=log)
    print("L1B_GEO_PGE:ERROR-2-[Unexpected Error]", file=log)
    log.flush()
    qa_file.close()
    raise
except:
    log = open(log_fname, "a")
    print("L1B_GEO_PGE:ERROR-2-[Unexpected Error]", file=log)
    log.flush()
    qa_file.close()
    raise

